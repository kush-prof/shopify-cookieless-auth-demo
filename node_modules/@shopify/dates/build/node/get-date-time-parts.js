"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDateTimeParts = getDateTimeParts;

var _decorators = require("@shopify/decorators");

var _utilities = require("./utilities");

var _sanitiseDateString = require("./sanitise-date-string");

var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _class;

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

const TWO_DIGIT_REGEX = /(\d{2})/;

function getDateTimeParts(date, timeZone) {
  return {
    year: () => DateTimeParts.getYear(date, timeZone),
    month: () => DateTimeParts.getMonth(date, timeZone),
    day: () => DateTimeParts.getDay(date, timeZone),
    weekday: () => DateTimeParts.getWeekday(date, timeZone),
    hour: () => DateTimeParts.getHour(date, timeZone),
    minute: () => DateTimeParts.getMinute(date, timeZone),
    second: () => DateTimeParts.getSecond(date, timeZone)
  };
}

function dateTimeCacheKey(unit) {
  return (date, timeZone) => `${unit}-${date.toString()}-${timeZone}`;
}

var Weekday;

(function (Weekday) {
  Weekday["Monday"] = "Monday";
  Weekday["Tuesday"] = "Tuesday";
  Weekday["Wednesday"] = "Wednesday";
  Weekday["Thursday"] = "Thursday";
  Weekday["Friday"] = "Friday";
  Weekday["Saturday"] = "Saturday";
  Weekday["Sunday"] = "Sunday";
})(Weekday || (Weekday = {}));

const weekdays = {
  Monday: 0,
  Tuesday: 1,
  Wednesday: 2,
  Thursday: 3,
  Friday: 4,
  Saturday: 5,
  Sunday: 6
};

function isWeekday(weekday) {
  return Object.keys(weekdays).some(key => key === weekday);
}

function assertNever(message) {
  throw new Error(message);
}

function getWeekdayValue(weekday) {
  if (!isWeekday(weekday)) {
    return assertNever(`Unexpected weekday: ${weekday}`);
  }

  return weekdays[weekday];
} // eslint-disable-next-line @typescript-eslint/no-extraneous-class


let DateTimeParts = (_dec = (0, _decorators.memoize)(dateTimeCacheKey('year')), _dec2 = (0, _decorators.memoize)(dateTimeCacheKey('month')), _dec3 = (0, _decorators.memoize)(dateTimeCacheKey('day')), _dec4 = (0, _decorators.memoize)(dateTimeCacheKey('weekday')), _dec5 = (0, _decorators.memoize)(dateTimeCacheKey('hour')), _dec6 = (0, _decorators.memoize)(dateTimeCacheKey('minute')), _dec7 = (0, _decorators.memoize)(dateTimeCacheKey('second')), _dec8 = (0, _decorators.memoize)(dateTimeCacheKey('timePartsFallback')), (_class = class DateTimeParts {
  static getYear(date, timeZone) {
    if (isNaN(date.valueOf())) {
      throw new Error(`Unable to parse date: ${date} for timezone: ${timeZone}`);
    }

    const yearString = (0, _utilities.formatDate)(date, 'en', {
      timeZone,
      year: 'numeric'
    });
    const sanitisedYearString = (0, _sanitiseDateString.sanitiseDateString)(yearString);
    const year = parseInt(sanitisedYearString, 10);

    if (isNaN(year)) {
      throw new Error(`Unable to parse year: '${yearString}'`);
    }

    return year;
  }

  static getMonth(date, timeZone) {
    const monthString = (0, _utilities.formatDate)(date, 'en', {
      timeZone,
      month: 'numeric'
    });
    const sanitisedMonthString = (0, _sanitiseDateString.sanitiseDateString)(monthString);
    const month = parseInt(sanitisedMonthString, 10);

    if (isNaN(month)) {
      throw new Error(`Unable to parse month: '${monthString}'`);
    }

    return month;
  }

  static getDay(date, timeZone) {
    const dayString = (0, _utilities.formatDate)(date, 'en', {
      timeZone,
      day: 'numeric'
    });
    const sanitisedDayString = (0, _sanitiseDateString.sanitiseDateString)(dayString);
    const day = parseInt(sanitisedDayString, 10);

    if (isNaN(day)) {
      throw new Error(`Unable to parse day: '${dayString}'`);
    }

    return day;
  }

  static getWeekday(date, timeZone) {
    const weekdayString = (0, _utilities.formatDate)(date, 'en', {
      timeZone,
      weekday: 'long'
    });
    const sanitisedWeekdayString = (0, _sanitiseDateString.sanitiseDateString)(weekdayString);
    return getWeekdayValue(sanitisedWeekdayString);
  }

  static getHour(date, timeZone) {
    const hourString = (0, _utilities.formatDate)(date, 'en', {
      timeZone,
      hour12: false,
      hour: 'numeric'
    });
    let hour = parseInt(hourString, 10);

    if (isNaN(hour)) {
      hour = DateTimeParts.getTimePartsFallback(date, timeZone).hour;
    }

    return hour;
  }

  static getMinute(date, timeZone) {
    const minuteString = (0, _utilities.formatDate)(date, 'en', {
      timeZone,
      minute: 'numeric'
    });
    let minute = parseInt(minuteString, 10);

    if (isNaN(minute)) {
      minute = DateTimeParts.getTimePartsFallback(date, timeZone).minute;
    }

    return minute;
  }

  static getSecond(date, timeZone) {
    const secondString = (0, _utilities.formatDate)(date, 'en', {
      timeZone,
      second: 'numeric'
    });
    let second = parseInt(secondString, 10);

    if (isNaN(second)) {
      second = DateTimeParts.getTimePartsFallback(date, timeZone).second;
    }

    return second;
  }

  static getTimePartsFallback(date, timeZone) {
    const timeString = (0, _utilities.formatDate)(date, 'en', {
      timeZone,
      hour12: false,
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    }); // In Microsoft Edge, Intl.DateTimeFormat returns invisible characters around the individual numbers

    const [dirtyHour, dirtyMinute, dirtySecond] = timeString.split(':');
    const rawHour = new RegExp(TWO_DIGIT_REGEX).exec(dirtyHour);
    const rawMinute = new RegExp(TWO_DIGIT_REGEX).exec(dirtyMinute);
    const rawSecond = new RegExp(TWO_DIGIT_REGEX).exec(dirtySecond);

    if (rawHour != null && rawMinute != null && rawSecond != null) {
      const hour = parseInt(rawHour[1], 10);
      const minute = parseInt(rawMinute[1], 10);
      const second = parseInt(rawSecond[1], 10);
      return {
        hour,
        minute,
        second
      };
    }

    throw new Error(`Unable to parse timeString: '${timeString}'`);
  }

}, (_applyDecoratedDescriptor(_class, "getYear", [_dec], Object.getOwnPropertyDescriptor(_class, "getYear"), _class), _applyDecoratedDescriptor(_class, "getMonth", [_dec2], Object.getOwnPropertyDescriptor(_class, "getMonth"), _class), _applyDecoratedDescriptor(_class, "getDay", [_dec3], Object.getOwnPropertyDescriptor(_class, "getDay"), _class), _applyDecoratedDescriptor(_class, "getWeekday", [_dec4], Object.getOwnPropertyDescriptor(_class, "getWeekday"), _class), _applyDecoratedDescriptor(_class, "getHour", [_dec5], Object.getOwnPropertyDescriptor(_class, "getHour"), _class), _applyDecoratedDescriptor(_class, "getMinute", [_dec6], Object.getOwnPropertyDescriptor(_class, "getMinute"), _class), _applyDecoratedDescriptor(_class, "getSecond", [_dec7], Object.getOwnPropertyDescriptor(_class, "getSecond"), _class), _applyDecoratedDescriptor(_class, "getTimePartsFallback", [_dec8], Object.getOwnPropertyDescriptor(_class, "getTimePartsFallback"), _class)), _class));